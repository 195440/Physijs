<!DOCTYPE html>
<html>
	<head>
		<title>Constraints | Physijs</title>
		<script type="text/javascript" src="lib/three.min.js"></script>
		<script type="text/javascript" src="lib/OrbitControls.js"></script>
		<script type="text/javascript" src="../dist/physi.js"></script>
		<link rel="stylesheet" type="text/css" href="styles.css"/>
	</head>
	<body>
		<script type="text/javascript">
			var renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor( new THREE.Color( 0xffffff ) );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			var scene = new physijs.Scene( '../dist/physijs-worker.js', { gravity: { x: 0, y: -9.8, z: 0 } } );

			var camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 100 );
			camera.position.set( 0, 7, 20 );
			var controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.center.set( 0, 2, 0 );

			var textureLoader = new THREE.TextureLoader();
			function loadRepeatingTexture( url, repeat ) {
				return textureLoader.load(
					url,
					function( texture ) {
						texture.anisotropy = renderer.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
						texture.repeat = repeat;
					}
				);
			}

			// light
			var ambient = new THREE.AmbientLight( 0x444444 );
			scene.add( ambient );

			var sunlight = new THREE.DirectionalLight( 0xbbbbbb );
			sunlight.position.set( 10, 30, 20 );
			sunlight.castShadow = true;
			sunlight.shadow.bias = -0.01;
			sunlight.shadow.mapSize.set( 1024, 1024 );
			sunlight.shadow.camera.left = sunlight.shadow.camera.top = -15;
			sunlight.shadow.camera.right = sunlight.shadow.camera.bottom = 15;
			sunlight.shadow.camera.near = 10;
			sunlight.shadow.camera.far = 50;
			scene.add( sunlight );

			var floor_material = new THREE.MeshPhongMaterial({
				map: loadRepeatingTexture( 'textures/cement/diffuse.jpg', new THREE.Vector2( 3, 3 ) ),
				normalMap: loadRepeatingTexture( 'textures/cement/normal.png', new THREE.Vector2( 3, 3 ) ),
				normalScale: new THREE.Vector2( 5, 5 ),
				specularMap: loadRepeatingTexture( 'textures/cement/specular.png', new THREE.Vector2( 3, 3 ) )
			});
			var floor = new physijs.Box( new THREE.BoxGeometry( 30, 0.1, 30 ), floor_material, { restitution: 0.1 } );
			floor.receiveShadow = true;
			scene.add( floor );

		// HINGE
			// build plank
			var plank_material = new THREE.MeshPhongMaterial({
				map: loadRepeatingTexture( 'textures/brick/diffuse.jpg', new THREE.Vector2( 2, 1 ) ),
				normalMap: loadRepeatingTexture( 'textures/brick/normal.png', new THREE.Vector2( 3, 3 ) ),
				normalScale: new THREE.Vector2( 5, 5 ),
				specularMap: loadRepeatingTexture( 'textures/brick/specular.png', new THREE.Vector2( 3, 3 ) )
			});
			var plank = new physijs.Box( new THREE.BoxGeometry( 4, 0.3, 8 ), plank_material, { mass: 10, restitution: 0.1 } );
			plank.receiveShadow = plank.castShadow = true;
			plank.position.set( -5, 3, 0 );
			scene.add( plank );

			var plank_constraint = new physijs.HingeConstraint(
				plank,
				new THREE.Vector3( -1, 0, 0 ).normalize(), // hinge axis
				new THREE.Vector3( 0, 0, -1 ) // point in plank rotating around hinge
			);
			plank_constraint.setLimit( -Math.PI / 8, 0 ); // lower limit, upper limit

			plank_constraint.setMotor( 100, 5 ); // torque, max_speed

			scene.add( plank_constraint );

			// balls
			var ball_geometry = new THREE.SphereGeometry( 0.5, 24, 24 );
			var ball_material = new THREE.MeshPhongMaterial({
				color: 0x882244
			});
			var ball_materials = [
				new THREE.MeshPhongMaterial({ color: 0x882244 }),
				new THREE.MeshPhongMaterial({ color: 0x228844 }),
				new THREE.MeshPhongMaterial({ color: 0x224488 })
			];
			var ball_index = 0;
			function makeBall() {
				var ball = new physijs.Sphere( ball_geometry, ball_materials[ball_index++], { mass: 2, friction: 0.1, restitution: 0.3 } );
				ball.receiveShadow = ball.castShadow = true;
				ball.position.set( -5, 5, 0 );
				ball.physics.linear_velocity.set( 0, -5, 0 );
				scene.add( ball );

				if ( ball_index === ball_materials.length ) {
					ball_index = 0;
				}
			}

			var physics_framerate = 1000 / 60;
			function onStep(step_index) {
				if ((step_index - 1) % 120 === 0) {
					makeBall();
				}

				controls.update();
				renderer.render( scene, camera );
				setTimeout( scene.step.bind( scene, physics_framerate / 1000, undefined, onStep ), physics_framerate );
			}
			scene.step( physics_framerate / 1000, undefined, onStep );

		</script>
	</body>
</html>